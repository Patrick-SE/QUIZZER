QUIZZER/
|-- app/
|   |-- (tabs)/
|       |-- _layout
|       |-- edit-question.jsx
|       |-- edit-quiz.jsx
|       |-- multiple-choice.jsx
|       |-- question-type.jsx
|       |-- quiz-screen.jsx
|       |-- quiz-taking.jsx
|       |-- short-text.jsx
|       |-- top-tabs.jsx
|       |-- true-false.jsx
|   |-- components/
|       |-- ExamContent.jsx
|       |-- QuizzesContent.jsx
|       |-- SettingItem.jsx
|       |-- ToggleSetting.jsx
|   |-- index.jsx
|
|-- context/
|   |-- QuizContext.jsx
|
|-- services/
|   |-- api.js
|
|-- styles/
|   |-- colors.js

quizzer_backend/
|-- add-question.php
|-- add-quiz.php
|-- api.php
|-- db.php
|-- delete-question.php
|-- delete-quiz.php
|-- get-question.php
|-- get-quizzes.php
|-- update-question.php
|-- update-quiz.php


-----
app/(tabs)/_layout.jsx

import { Stack } from 'expo-router';
import { QuizProvider } from '../../context/QuizContext';

export default function Layout() {
  return (
    <QuizProvider>
      <Stack screenOptions={{ headerShown: false }} />
    </QuizProvider>
  );
}

-----
app/(tabs)/edit-question.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext'; // ‚úÖ Import context
import { updateQuestionInDB } from '../../services/api';

export default function EditQuestionScreen() {
  const { quizName, questionId } = useLocalSearchParams();
  const { quizQuestions, updateQuestion } = useQuiz(); // ‚úÖ Get stored questions & update function
  const router = useRouter();

  const questionData = quizQuestions[quizName]?.find(q => q.id == questionId) || {};

  const [editedQuestion, setEditedQuestion] = useState(questionData.question || '');
  const [editedCorrectAnswer, setEditedCorrectAnswer] = useState(questionData.correctAnswer || '');

  const handleSave = async () => {
    // ‚úÖ Call backend to update in MySQL
    const response = await updateQuestionInDB(questionId, {
      question: editedQuestion.trim(),
      correctAnswer: editedCorrectAnswer.trim()
    });

    if (response?.success) {
      // ‚úÖ Update local state in context
      updateQuestion(quizName, questionId, editedQuestion, editedCorrectAnswer);

      // ‚úÖ Navigate back
      router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName } });
    } else {
      console.error('‚ùå Failed to update question in DB');
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="black" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{quizName}</Text>
        <TouchableOpacity onPress={handleSave}>
          <Ionicons name="save" size={24} color="#009688" />
        </TouchableOpacity>
      </View>

      <Text style={styles.label}>Question</Text>
      <TextInput 
        style={styles.input}
        value={editedQuestion}
        onChangeText={setEditedQuestion}
      />

      <Text style={styles.label}>Correct Answer</Text>
      <TextInput 
        style={styles.input}
        value={editedCorrectAnswer}
        onChangeText={setEditedCorrectAnswer}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 6,
    padding: 10,
  },
  questionItem: {
    padding: 16,
    borderBottomColor: '#eee',
    borderBottomWidth: 1,
  },
  questionText: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  answerText: {
    fontSize: 14,
    color: '#666',
  },
});

-------
app/(tabs)/edit-quiz.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { StyleSheet, Text, TextInput, TouchableOpacity, View, } from 'react-native';
import { useQuiz } from '../../context/QuizContext'; // ‚úÖ Import QuizContext
import { updateQuiz } from '../../services/api'; // ‚úÖ Import API function correctly

export default function EditQuiz() {
  const { name } = useLocalSearchParams();
  const [newName, setNewName] = useState(name || '');
  const router = useRouter();
  const { quizzes } = useQuiz(); // ‚úÖ Get quizzes from context

  const handleSave = async () => {
    if (name && newName.trim()) {
      console.log("Renaming quiz:", name, "New Name:", newName);
  
      const quizToUpdate = quizzes.find(q => q.name === name); // ‚úÖ Find quiz by name to get its ID
      if (!quizToUpdate) {
        console.error("Quiz not found!");
        return;
      }
  
      const success = await updateQuiz(quizToUpdate.id, newName.trim()); // ‚úÖ Use ID, not name
      console.log("Raw API Response:", success);
  
      if (success) {
        router.push('/(tabs)/top-tabs');
        router.replace({ pathname: '/(tabs)/quiz-screen', params: { name: newName.trim() } });
      } else {
        console.error("Failed to update quiz in MySQL!");
      }
    }
  };   

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="black" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Edit Quiz</Text>
        <TouchableOpacity onPress={handleSave}>
          <Ionicons name="save" size={24} color="#009688" />
        </TouchableOpacity>
      </View>

      <Text style={styles.label}>Name</Text>
      <TextInput
        style={styles.input}
        value={newName}
        onChangeText={setNewName}
        placeholder="Enter new quiz name"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 6,
    padding: 10,
  },
});

-----
app/(tabs)/multiple-choice.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Modal, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext'; // ‚úÖ Import context
import { updateQuestionInDB } from '../../services/api';

export default function MultipleChoiceScreen() {

  const [errorMessage, setErrorMessage] = useState('');
  const [errorVisible, setErrorVisible] = useState(false);

  const { addQuestion } = useQuiz(); // ‚úÖ Get function to store questions

  const { quizName, quizId, questionId } = useLocalSearchParams();
  const { quizQuestions, updateQuestion } = useQuiz();
  const router = useRouter();
  
  const questionData = quizQuestions[quizId]?.find(q => q.id === parseInt(questionId)) || {};
  
  const [question, setQuestion] = useState(questionData.question || '');
  const [correctAnswer, setCorrectAnswer] = useState(questionData.correctAnswer || '');
  const [wrongAnswer1, setWrongAnswer1] = useState(questionData.wrongAnswers?.[0] || '');
  const [wrongAnswer2, setWrongAnswer2] = useState(questionData.wrongAnswers?.[1] || '');
  const [wrongAnswer3, setWrongAnswer3] = useState(questionData.wrongAnswers?.[2] || '');  

  const handleSave = async () => {
    if (!question.trim()) {
      setErrorMessage("Question can't be blank");
      setErrorVisible(true);
      return;
    }
  
    const formattedQuestion = question.trim().toLowerCase();
    const answers = [correctAnswer, wrongAnswer1, wrongAnswer2, wrongAnswer3]
      .map(ans => ans.trim().toLowerCase());
  
    if (answers.includes(formattedQuestion)) {
      setErrorMessage("The question and answers must be different.");
      setErrorVisible(true);
      return;
    }

    if (questionId) {
      // ‚úÖ Update both MySQL and context
      const response = await updateQuestionInDB(questionId, {
        type: 'multiple-choice',
        question: question.trim(),
        correctAnswer: correctAnswer.trim(),
        wrongAnswers: [wrongAnswer1.trim(), wrongAnswer2.trim(), wrongAnswer3.trim()],
        answerContains: '',
        answerEquals: ''
      });

      console.log('Update response:', response); // üîç Check this

      updateQuestion(
        quizId,
        questionId,
        question,
        correctAnswer,
        [wrongAnswer1, wrongAnswer2, wrongAnswer3],
        '',
        ''
      );
    } else {
      addQuestion(quizId, {
        type: 'multiple-choice',
        question,
        correctAnswer,
        wrongAnswers: [wrongAnswer1, wrongAnswer2, wrongAnswer3],
        quiz_id: quizId
      });
    }

    router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName, id: quizId } });
  };  

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
      <TouchableOpacity onPress={() => router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName } })}>
        <Ionicons name="arrow-back" size={24} color="black" />
      </TouchableOpacity>
        <Text style={styles.headerTitle}>Multiple Choice</Text>
        <TouchableOpacity onPress={handleSave}>
          <Ionicons name="save" size={24} color="#009688" />
        </TouchableOpacity>
      </View>

      {/* Question Input */}
      <Text style={styles.label}>Question</Text>
      <TextInput
        style={styles.input}
        value={question}
        onChangeText={setQuestion}
        placeholder="Enter question"
      />

      {/* Answer Inputs */}
      <Text style={styles.label}>Correct Answer</Text>
      <View style={styles.answerRow}>
        <TextInput
          style={styles.input}
          value={correctAnswer}
          onChangeText={setCorrectAnswer}
          placeholder="Enter correct answer"
        />
        <Ionicons name="checkmark-circle" size={24} color="green" />
      </View>

      <Text style={styles.label}>Wrong Answers</Text>
      {[
        [wrongAnswer1, setWrongAnswer1],
        [wrongAnswer2, setWrongAnswer2],
        [wrongAnswer3, setWrongAnswer3]
      ].map(([value, setter], index) => (
        <View key={index} style={styles.answerRow}>
          <TextInput
            style={styles.input}
            value={value}
            onChangeText={setter}
            placeholder={`Wrong answer ${index + 1}`}
          />
          <Ionicons name="close-circle" size={24} color="red" />
        </View>
      ))}

      {/* Modal for Validation */}
      <Modal visible={errorVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Validation Error</Text>
            <Text style={styles.modalText}>{errorMessage}</Text>
            <TouchableOpacity onPress={() => setErrorVisible(false)} style={styles.modalButton}>
              <Text style={styles.modalButtonText}>OK</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', padding: 20 },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 20 },
  headerTitle: { fontSize: 18, fontWeight: 'bold' },
  label: { fontSize: 16, marginBottom: 8 },
  input: { borderWidth: 1, borderColor: '#ccc', borderRadius: 6, padding: 10, flex: 1 },
  answerRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 12 },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
  },
  modalContent: {
    backgroundColor: '#fff',
    width: '80%',
    padding: 20,
    borderRadius: 12,
    elevation: 10,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 8,
  },
  modalText: {
    fontSize: 14,
    color: '#333',
    textAlign: 'center',
    marginBottom: 12,
  },
  modalButton: {
    backgroundColor: '#009688',
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 6,
  },
  modalButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
});

-------
app/(tabs)/question-type.jsx

import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Modal, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

export default function QuestionType() {
  const { quizName } = useLocalSearchParams();
  const router = useRouter();
  const [modalVisible, setModalVisible] = useState(true); // ‚úÖ Modal now starts visible

  const handleSelect = (screen) => {
    setModalVisible(false); // ‚úÖ Close modal before navigating
    setTimeout(() => router.push({ pathname: `/(tabs)/${screen}`, params: { quizName } }), 100);
  };

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()}>
          <Text style={styles.backText}>‚Üê {quizName}</Text>
        </TouchableOpacity>
      </View>

      {/* Question Type Modal */}
      <Modal visible={modalVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Question Type</Text>

            <TouchableOpacity onPress={() => handleSelect('multiple-choice')}>
              <Text style={styles.option}>Multiple Choice</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => handleSelect('short-text')}>
              <Text style={styles.option}>Short Text</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => handleSelect('true-false')}>
              <Text style={styles.option}>True or False</Text>
            </TouchableOpacity>

            {/* Back Button */}
            <TouchableOpacity 
              onPress={() => {
                setModalVisible(false); // ‚úÖ Hide modal
                router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName } }); // ‚úÖ Navigate to quiz screen
              }} 
              style={styles.backButton}
            >
              <Text style={styles.backText}>Back</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', padding: 20 },
  header: { marginBottom: 20 },
  backText: { fontSize: 16, color: '#009688', fontWeight: 'bold' },
  modalOverlay: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.3)' },
  modalContent: { backgroundColor: '#fff', width: '80%', padding: 20, borderRadius: 12, elevation: 10, alignItems: 'center' },
  modalTitle: { fontWeight: 'bold', fontSize: 16, marginBottom: 12, textAlign: 'center' },
  option: { paddingVertical: 12, fontSize: 16, color: '#009688', fontWeight: 'bold' },
  backButton: { marginTop: 20, paddingVertical: 10, width: '100%', alignItems: 'center', borderTopColor: '#ccc', borderTopWidth: 1 },
});

-----
app/(tabs)/quiz-screen.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useEffect, useState } from 'react';
import { FlatList, Modal, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext';
import { deleteQuestion } from "../../services/api"; // ‚úÖ Import delete function

export default function QuizScreen() {
  const params = useLocalSearchParams();
  const router = useRouter();

  const [modalVisible, setModalVisible] = useState(false);
  const [quizName, setQuizName] = useState(params.name || '');
  const [quizId, setQuizId] = useState(params.id || '');
  const { quizQuestions, removeQuestion } = useQuiz();

  const [confirmDeleteModalVisible, setConfirmDeleteModalVisible] = useState(false);
  const [selectedQuestion, setSelectedQuestion] = useState(null);

  // ‚úÖ Fetch latest from context using quizId instead of quizName
  const questions = quizQuestions[quizId] || [];

  useEffect(() => {
    if (params.name) setQuizName(params.name);
    if (params.id) setQuizId(params.id);
  }, [params.name, params.id]);

  // ‚úÖ Debug what's loaded
  console.log("üìã Questions in quiz-screen:", questions);

  const handleSelect = (screen) => {
    setModalVisible(false);
    setTimeout(() => router.push({
      pathname: `/(tabs)/${screen}`,
      params: { quizName, quizId } // ‚úÖ Pass both
    }), 100);
  };

  const handleDeleteQuestion = async () => {
    console.log("üß™ Delete button pressed");

    if (selectedQuestion) {
      console.log("Selected question ID:", selectedQuestion?.id);
      const success = await deleteQuestion(selectedQuestion.id);
      console.log("Delete response:", success);

      setConfirmDeleteModalVisible(false);
      setSelectedQuestion(null); // ‚úÖ Reset selection regardless

      if (success) {
        removeQuestion(quizId, selectedQuestion.id); // ‚úÖ Remove from local state
      } else {
        console.error("‚ùå Failed to delete question");
      }
    }
  };

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.push({ pathname: '/(tabs)/top-tabs' })}>
          <Ionicons name="arrow-back" size={24} color="black" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{quizName}</Text>
        <View style={{ flexDirection: 'row' }}>
          <Ionicons name="pencil" size={24} color="black" style={{ marginRight: 16 }} />
          <Ionicons name="search" size={24} color="black" />
        </View>
      </View>

      {/* Questions List */}
      {questions.length === 0 ? (
        <Text style={styles.placeholder}>No questions yet</Text>
      ) : (
        <FlatList
          data={questions}
          keyExtractor={(item, index) => index.toString()}
          renderItem={({ item, index }) => {
          console.log(`üìå Rendering Q#${index + 1}: ${item.type} ${item.correctAnswer || item.answerEquals || item.answerContains}`);

            // Update the answer display logic to be more robust
            let answerDisplay = 'No answer';
            if (item.type === 'short-text') {
              answerDisplay = item.answerEquals || item.answerContains || 'No answer';
            } else if (item.type === 'true-false') {
              // Explicit true-false handling
              if (item.correctAnswer === true || item.correctAnswer === 'true' || item.correctAnswer === 'True') {
                answerDisplay = 'True';
              } else if (item.correctAnswer === false || item.correctAnswer === 'false' || item.correctAnswer === 'False') {
                answerDisplay = 'False';
              } else {
                answerDisplay = 'No answer';
              }
            } else if (item.type === 'multiple-choice') {
              answerDisplay = item.correctAnswer || 'No answer';
            }

            return (
              <TouchableOpacity
                onPress={() =>
                  router.push({
                    pathname: `/(tabs)/${item.type}`,
                    params: { quizName, quizId, questionId: item.id },
                  })
                }
                onLongPress={() => {
                  setSelectedQuestion(item);
                  setConfirmDeleteModalVisible(true);
                }}
              >
                <View style={[styles.questionItem, styles.questionSeparator]}>
                  <Text style={styles.questionText}>{item.question}</Text>
                  <Text style={[styles.answerText, styles.answerHighlight]}>
                    {answerDisplay}
                  </Text>
                </View>
              </TouchableOpacity>
            );
          }}
        />
      )}

      {/* Floating Action Button */}
      <TouchableOpacity style={styles.fab} onPress={() => setModalVisible(true)}>
        <Ionicons name="add" size={28} color="white" />
      </TouchableOpacity>

      {/* Modal: Choose Question Type */}
      <Modal visible={modalVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Choose a Question Type</Text>

            <TouchableOpacity onPress={() => handleSelect('multiple-choice')}>
              <Text style={styles.option}>Multiple Choice</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => handleSelect('short-text')}>
              <Text style={styles.option}>Short Text</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => handleSelect('true-false')}>
              <Text style={styles.option}>True or False</Text>
            </TouchableOpacity>

            <TouchableOpacity onPress={() => setModalVisible(false)} style={styles.backButton}>
              <Text style={styles.backText}>Back</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Confirm Delete Modal */}
      <Modal visible={confirmDeleteModalVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Confirm Delete</Text>
            <Text style={styles.modalText}>
              Are you sure you want to delete this question?
            </Text>
            <Text style={{ fontStyle: 'italic', marginVertical: 10 }}>
              "{selectedQuestion?.question}"
            </Text>
            <View style={styles.modalButtons}>
              <TouchableOpacity 
                style={[styles.modalBtn, { backgroundColor: '#ccc' }]} 
                onPress={() => setConfirmDeleteModalVisible(false)}>
                <Text style={{ fontWeight: 'bold' }}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={[styles.modalBtn, { backgroundColor: '#F44336' }]} 
                onPress={handleDeleteQuestion}>
                <Text style={{ color: 'white', fontWeight: 'bold' }}>Delete</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  fab: {
    position: 'absolute',
    bottom: 25,
    right: 25,
    backgroundColor: '#009688',
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5,
  },
  placeholder: {
    marginTop: 50,
    textAlign: 'center',
    fontSize: 16,
    color: '#666',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
  },
  modalContent: {
    backgroundColor: '#fff',
    width: '80%',
    padding: 20,
    borderRadius: 12,
    elevation: 10,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 12,
    textAlign: 'center',
  },
  option: {
    paddingVertical: 12,
    fontSize: 16,
    color: '#009688',
    fontWeight: 'bold',
  },
  backButton: {
    marginTop: 20,
    paddingVertical: 10,
    width: '100%',
    alignItems: 'center',
    borderTopColor: '#ccc',
    borderTopWidth: 1,
  },
  questionSeparator: {
    marginBottom: 16,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  answerHighlight: {
    color: '#009688',
    fontWeight: 'bold',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 10,
  },
    modalBtn: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
    marginHorizontal: 10,
  },
  modalText: {
    textAlign: 'center',
    color: '#333',
    fontSize: 14,
  },
});

-------
app/(tabs)/quiz-taking.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useEffect, useState } from 'react';
import { StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext'; // ‚úÖ Add this back

export default function QuizTakingScreen() {
    const router = useRouter();
    const params = useLocalSearchParams();
    const selectedQuizzes = Array.isArray(params.quizzes) ? params.quizzes : [params.quizzes];
    const { quizQuestions } = useQuiz(); // ‚úÖ Restore quizQuestions
    
    const [selectedAnswer, setSelectedAnswer] = useState(null); // ‚úÖ Track user selection
    const [locked, setLocked] = useState(false); // ‚úÖ Prevent answer changes after selection

    const [userAnswer, setUserAnswer] = useState('');
    const [isCorrect, setIsCorrect] = useState(null); // ‚úÖ Tracks if answer is correct or wrong

    const [allQuestions, setAllQuestions] = useState([]);
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const currentQuestion = allQuestions[currentQuestionIndex] || null;
    
    const [showFullAnswer, setShowFullAnswer] = useState(false); // ‚úÖ Add this state to track when to show the full answer

    useEffect(() => {
        console.log("Selected quizzes:", selectedQuizzes);
        console.log("Quiz questions:", quizQuestions);
    
        if (selectedQuizzes.length && allQuestions.length === 0) {
            const newQuestions = selectedQuizzes.flatMap(quiz => quizQuestions[quiz] || []);
            if (newQuestions.length > 0) {
                setAllQuestions(newQuestions); // ‚úÖ Only update when necessary
            }
        }
    }, [selectedQuizzes, quizQuestions, allQuestions]); // ‚úÖ Now checks all relevant state    

    const handleAnswerSelection = (answer) => {
        if (!locked) {
            setSelectedAnswer(answer);
            setLocked(true); // ‚úÖ Prevents changing the answer after selection
        }
    };

    const handleCheckAnswer = () => {
        if (!currentQuestion) {
            console.error("currentQuestion is undefined");
            setIsCorrect(false);
            return;
        }
    
        const userInput = userAnswer.trim().toLowerCase();
        const correctEquals = currentQuestion.answerEquals?.trim().toLowerCase() === userInput;
    
        const correctContains = currentQuestion.answerContains 
            ? [...currentQuestion.answerContains.trim().toLowerCase()].some(char => userInput.includes(char)) 
            : false;
    
        setIsCorrect(correctEquals || correctContains); // ‚úÖ Runs ONLY when the button is clicked
    
        setShowFullAnswer(!correctEquals && correctContains); // ‚úÖ Show full correct answer if the user answered incorrectly OR partially
    };

    const handleNextQuestion = () => {
        if (currentQuestionIndex < allQuestions.length - 1) {
            setCurrentQuestionIndex(prev => prev + 1);
            setSelectedAnswer(null);  // ‚úÖ Reset selection when moving to the next question
            setLocked(false);         // ‚úÖ Allow new selection for the next question
            setUserAnswer('');  // ‚úÖ Clear input field for next question
            setIsCorrect(null); // ‚úÖ Reset validation state
            setShowFullAnswer(false); // ‚úÖ Hides complete answer for new question
        } else {
            router.push('/(tabs)/quiz-summary'); // ‚úÖ Redirects to summary screen
        }
    };   

    return (
        <View style={styles.container}>
            {/* Header */}
            <View style={styles.header}>
                <TouchableOpacity onPress={() => router.back()}>
                    <Ionicons name="arrow-back" size={24} color="black" />
                </TouchableOpacity>
                <Text style={styles.quizName}>{selectedQuizzes.join(', ')}</Text>
                <Text style={styles.questionCount}>{`Question ${currentQuestionIndex + 1}/${allQuestions.length}`}</Text>
            </View>

            {/* Question Display */}
            {currentQuestion ? (
            <>
                <Text style={styles.questionText}>{currentQuestion.question}</Text>

                {/* Render Different Question Types */}
                {currentQuestion.type === 'multiple-choice' && (
                <View style={styles.answersContainer}>
                    {currentQuestion.wrongAnswers.concat(currentQuestion.correctAnswer).sort().map((answer, index) => (
                    <TouchableOpacity 
                        key={index} 
                        style={[
                        styles.answerOption, 
                        locked && selectedAnswer === answer && (selectedAnswer === currentQuestion.correctAnswer ? styles.correctAnswer : styles.wrongAnswer),
                        locked && answer === currentQuestion.correctAnswer ? styles.correctAnswer : null // ‚úÖ Highlight correct answer
                        ]}
                        onPress={() => handleAnswerSelection(answer)}
                    >
                        <Text style={[styles.answerText, locked && selectedAnswer === answer && { color: 'white' }]}>
                        {answer}
                        </Text>
                    </TouchableOpacity>
                    ))}
                </View>
                )}

                {/* Short Text */}
                {currentQuestion.type === 'short-text' && (
                <View style={styles.inputContainer}>
                    <TextInput 
                    style={[styles.input, isCorrect !== null && (isCorrect ? styles.correctAnswer : styles.wrongAnswer)]}
                    placeholder="Enter answer" 
                    value={userAnswer} 
                    onChangeText={setUserAnswer}
                    />

                    {/* ‚úÖ Show full correct answer if user answered wrong OR had a partial match */}
                    {showFullAnswer && (
                    <View style={styles.answerRow}>
                        <Text style={styles.fullAnswerText}>
                        The Answer is: {currentQuestion.answerContains || currentQuestion.answerEquals}
                        </Text>
                        <Ionicons name="checkmark-circle" size={24} color="green" />
                    </View>
                    )}

                    <TouchableOpacity onPress={handleCheckAnswer} style={styles.checkButton}>
                        <Text style={styles.checkButtonText}>Check Answer</Text>
                    </TouchableOpacity>

                </View>
                )}

                {/* True or False */}
                {currentQuestion.type === 'true-false' && (
                <View style={styles.trueFalseContainer}>
                    <TouchableOpacity 
                    style={[
                        styles.trueFalseOption, 
                        locked && selectedAnswer === 'True' && (selectedAnswer === currentQuestion.correctAnswer ? styles.correctAnswer : styles.wrongAnswer),
                        locked && currentQuestion.correctAnswer === 'True' ? styles.correctAnswer : null // ‚úÖ Show correct answer if user is wrong
                    ]} 
                    onPress={() => handleAnswerSelection('True')}
                    >
                    <Text style={[styles.trueFalseText, selectedAnswer === 'True' && { color: 'white' }]}>True</Text>
                    </TouchableOpacity>

                    <TouchableOpacity 
                    style={[
                        styles.trueFalseOption, 
                        locked && selectedAnswer === 'False' && (selectedAnswer === currentQuestion.correctAnswer ? styles.correctAnswer : styles.wrongAnswer),
                        locked && currentQuestion.correctAnswer === 'False' ? styles.correctAnswer : null // ‚úÖ Show correct answer if user is wrong
                    ]} 
                    onPress={() => handleAnswerSelection('False')}
                    >
                    <Text style={[styles.trueFalseText, selectedAnswer === 'False' && { color: 'white' }]}>False</Text>
                    </TouchableOpacity>
                </View>
                )}

                {/* Next Button */}
                <TouchableOpacity onPress={handleNextQuestion} style={styles.nextButton}>
                <Text style={styles.nextButtonText}>Next</Text>
                </TouchableOpacity>
            </>
            ) : (
            <Text style={styles.noQuestions}>No questions available.</Text>
            )}
        </View>
    );
}

const styles = StyleSheet.create({
    container: { flex: 1, backgroundColor: '#fff', padding: 20 },

    header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 },
    quizName: { fontSize: 20, fontWeight: 'bold', color: '#009688' },
    questionCount: { fontSize: 16, color: '#666' },

    questionText: { fontSize: 22, fontWeight: 'bold', marginBottom: 20, textAlign: 'center', color: '#333' },

    // Multiple Choice Enhancements
    answersContainer: { marginTop: 20, gap: 15 },
    answerOption: { 
        paddingVertical: 16, 
        borderWidth: 2, 
        borderColor: '#009688', 
        borderRadius: 10, 
        alignItems: 'center', 
        backgroundColor: '#f9f9f9',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2
    },
    answerText: { fontSize: 18, fontWeight: 'bold', color: '#333' },

    // Short Text Enhancements
    inputContainer: { alignItems: 'center', marginTop: 20 },
    input: { 
        width: '100%',
        padding: 12, 
        fontSize: 18, 
        borderWidth: 1, 
        borderColor: '#009688', 
        borderRadius: 8, 
        backgroundColor: '#fff',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2
    },
    checkButton: {
        marginTop: 15, 
        backgroundColor: '#009688', 
        paddingVertical: 14, 
        paddingHorizontal: 25, 
        borderRadius: 8,
        alignItems: 'center'
    },
    checkButtonText: { color: 'white', fontWeight: 'bold', fontSize: 18 },

    highlightText: {
        color: '#DC3545', // ‚úÖ Make the full answer stand out
    },
    answerRow: { 
        flexDirection: 'row', 
        alignItems: 'center', 
        justifyContent: 'space-between', 
        marginTop: 10 
    },
    fullAnswerText: { 
        fontSize: 18, 
        color: '#333',
        fontWeight: 'bold' 
    },

    // True/False Enhancements
    trueFalseContainer: { 
        flexDirection: 'row', 
        justifyContent: 'space-evenly', 
        marginTop: 30 
    },
    trueFalseOption: { 
        width: '45%', 
        paddingVertical: 18, 
        borderRadius: 12, 
        alignItems: 'center', 
        borderWidth: 2, 
        borderColor: '#009688',
        backgroundColor: '#f9f9f9',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 3 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
        elevation: 3 
    },
    correctAnswer: { 
        backgroundColor: '#4CAF50', 
        borderColor: '#4CAF50',
    }, // ‚úÖ Turns GREEN if correct
    wrongAnswer: { 
        backgroundColor: '#F44336', 
        borderColor: '#F44336',
    },  // ‚úÖ Turns RED if incorrect
    trueFalseText: { 
        fontSize: 20, 
        fontWeight: 'bold', 
        color: '#333' // ‚úÖ Default color is visible
    },    

    // Next Button
    nextButton: { 
        backgroundColor: '#009688', 
        padding: 15, 
        borderRadius: 8, 
        alignItems: 'center',
        marginTop: 20 
    },
    nextButtonText: { color: 'white', fontWeight: 'bold', fontSize: 18 },
    noQuestions: { fontSize: 18, color: '#666', textAlign: 'center' }
});

--------
app/(tabs)/short-text.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Modal, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext';
import { updateQuestionInDB } from '../../services/api';

export default function ShortTextScreen() {
  const [errorMessage, setErrorMessage] = useState('');
  const [errorVisible, setErrorVisible] = useState(false);

  const { quizName, quizId, questionId } = useLocalSearchParams();
  const { quizQuestions, updateQuestion, addQuestion } = useQuiz();
  const router = useRouter();

  const questionData = quizQuestions[quizId]?.find(q => q.id === parseInt(questionId)) || {};

  const [question, setQuestion] = useState(questionData.question || '');
  const [answerContains, setAnswerContains] = useState(questionData.answerContains || '');
  const [answerEquals, setAnswerEquals] = useState(questionData.answerEquals || '');

  const handleSave = async () => {
    if (!question.trim()) {
      setErrorMessage("Question can't be blank");
      setErrorVisible(true);
      return;
    }
  
    // ‚úÖ Ensure only one answer type is stored
    let updatedAnswerContains = answerContains.trim();
    let updatedAnswerEquals = answerEquals.trim();
  
    if (updatedAnswerContains) updatedAnswerEquals = ''; // ‚úÖ Clear "Equals" when "Contains" is used
    else if (updatedAnswerEquals)  updatedAnswerContains = ''; // ‚úÖ Clear "Contains" when "Equals" is used
  
    if (questionId) {
      const response = await updateQuestionInDB(questionId, {
        type: 'short-text',
        question: question.trim(),
        correctAnswer: '',
        wrongAnswers: [],
        answerContains: updatedAnswerContains,
        answerEquals: updatedAnswerEquals
      });

      if (!response.success) {
        setErrorMessage("Failed to update question in database");
        setErrorVisible(true);
        return;
      }

      updateQuestion(
        quizId,
        questionId,
        question,
        '',
        [],
        updatedAnswerContains,
        updatedAnswerEquals
      );
    } else {
      addQuestion(quizId, {
        type: 'short-text',
        question,
        answerContains: updatedAnswerContains,
        answerEquals: updatedAnswerEquals,
        quiz_id: parseInt(quizId),
      });
    }
  
    router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName, id: quizId } });
  };  

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName } })}>
          <Ionicons name="arrow-back" size={24} color="black" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Short Text</Text>
        <TouchableOpacity onPress={handleSave}>
          <Ionicons name="save" size={24} color="#009688" />
        </TouchableOpacity>
      </View>

      {/* Question Input */}
      <Text style={styles.label}>Question</Text>
      <TextInput
        style={styles.input}
        value={question}
        onChangeText={setQuestion}
        placeholder="Enter question"
      />

      {/* Answer Contains */}
      <Text style={styles.label}>Correct if the answer contains</Text>
      <View style={styles.answerRow}>
        <TextInput
          style={styles.input}
          value={answerContains}
          onChangeText={setAnswerContains}
          placeholder="Enter accepted words"
        />
        <Ionicons name="checkmark-circle-outline" size={24} color="purple" />
      </View>

      {/* Answer Equals */}
      <Text style={styles.label}>Correct if the answer is equal to</Text>
      <View style={styles.answerRow}>
        <TextInput
          style={styles.input}
          value={answerEquals}
          onChangeText={setAnswerEquals}
          placeholder="Enter exact answer"
        />
        <Ionicons name="checkmark-circle" size={24} color="green" />
      </View>

      {/* Modal for Validation */}
      <Modal visible={errorVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Validation Error</Text>
            <Text style={styles.modalText}>{errorMessage}</Text>
            <TouchableOpacity onPress={() => setErrorVisible(false)} style={styles.modalButton}>
              <Text style={styles.modalButtonText}>OK</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', padding: 20 },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 20 },
  headerTitle: { fontSize: 18, fontWeight: 'bold' },
  label: { fontSize: 16, marginBottom: 8 },
  input: { borderWidth: 1, borderColor: '#ccc', borderRadius: 6, padding: 10, flex: 1 },
  answerRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 12 },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
  },
  modalContent: {
    backgroundColor: '#fff',
    width: '80%',
    padding: 20,
    borderRadius: 12,
    elevation: 10,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 8,
  },
  modalText: {
    fontSize: 14,
    color: '#333',
    textAlign: 'center',
    marginBottom: 12,
  },
  modalButton: {
    backgroundColor: '#009688',
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 6,
  },
  modalButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },  
});

------
app/(tabs)/top-tabs.jsx

import { Ionicons } from '@expo/vector-icons';
import { useState } from 'react';
import { StatusBar, Text, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext';
import ExamContent from '../components/ExamContent';
import QuizzesContent from '../components/QuizzesContent';

export default function TopTabsScreen() {
  const [activeTab, setActiveTab] = useState('exam');
  const { quizzes, setQuizzes } = useQuiz(); // üíæ This keeps your quizzes alive even when switching tabs

  const renderHeaderRight = () => {
    if (activeTab === 'exam') {
      return (
        <TouchableOpacity>
          <Ionicons name="settings-outline" size={24} color="white" />
        </TouchableOpacity>
      );
    } else {
      return (
        <View style={{ flexDirection: 'row' }}>
          <Ionicons name="search" size={24} color="white" style={{ marginRight: 16 }} />
          <Ionicons name="ellipsis-vertical" size={24} color="white" />
        </View>
      );
    }
  };

  const renderScreen = () => {
    if (activeTab === 'exam') return <ExamContent />;
    if (activeTab === 'quizzes') return <QuizzesContent quizzes={quizzes} setQuizzes={setQuizzes} />;
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar barStyle="light-content" />

      {/* Top Header */}
      <View style={{
        backgroundColor: '#009688',
        paddingTop: 50,
        paddingBottom: 10,
        paddingHorizontal: 20,
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
      }}>
        <Text style={{ color: 'white', fontSize: 22, fontWeight: 'bold' }}>Quizzer</Text>
        {renderHeaderRight()}
      </View>

      {/* Tab Bar */}
      <View style={{
        flexDirection: 'row',
        justifyContent: 'space-around',
        borderBottomColor: '#ccc',
        borderBottomWidth: 1,
      }}>
        <TouchableOpacity onPress={() => setActiveTab('exam')}>
          <Text style={{
            padding: 10,
            fontWeight: 'bold',
            color: activeTab === 'exam' ? '#009688' : '#666',
            borderBottomWidth: activeTab === 'exam' ? 2 : 0,
            borderBottomColor: '#009688'
          }}>
            EXAM
          </Text>
        </TouchableOpacity>
        <TouchableOpacity onPress={() => setActiveTab('quizzes')}>
          <Text style={{
            padding: 10,
            fontWeight: 'bold',
            color: activeTab === 'quizzes' ? '#009688' : '#666',
            borderBottomWidth: activeTab === 'quizzes' ? 2 : 0,
            borderBottomColor: '#009688'
          }}>
            QUIZZES
          </Text>
        </TouchableOpacity>
      </View>

      {/* Content */}
      {renderScreen()}
    </View>
  );
}

-------
app/(tabs)/true-false.jsx

import { Ionicons } from '@expo/vector-icons';
import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Modal, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext';
import { updateQuestionInDB } from '../../services/api';

export default function TrueFalseScreen() {
  const [errorMessage, setErrorMessage] = useState('');
  const [errorVisible, setErrorVisible] = useState(false);

  const { quizName, quizId, questionId } = useLocalSearchParams();
  const { quizQuestions, updateQuestion, addQuestion } = useQuiz();
  const router = useRouter();

  const questionData = quizQuestions[quizId]?.find(q => q.id === parseInt(questionId)) || {};

  const [question, setQuestion] = useState(questionData.question || '');
  const [selectedAnswer, setSelectedAnswer] = useState(questionData.correctAnswer || null);

  const handleSave = async () => {
    console.log('Saving with:', { question, selectedAnswer });
    if (!question.trim()) {
      setErrorMessage("Question can't be blank");
      setErrorVisible(true);
      return;
    }

    // Explicit true-false validation
    if (selectedAnswer !== 'True' && selectedAnswer !== 'False') {
      setErrorMessage("Please select either True or False");
      setErrorVisible(true);
      return;
    }
  
    if (selectedAnswer === null) {
      setErrorMessage("Please select an answer");
      setErrorVisible(true);
      return;
    }
  
    if (questionId) {
      const response = await updateQuestionInDB(questionId, {
        type: 'true-false',
        question: question.trim(),
        correctAnswer: selectedAnswer.trim(),
        wrongAnswers: [],
        answerContains: '',
        answerEquals: ''
      });

      if (!response.success) {
        setErrorMessage("Failed to update question in database");
        setErrorVisible(true);
        return;
      }

      updateQuestion(
        quizId,
        questionId,
        question,
        selectedAnswer,
        [],
        '',
        ''
      );
    } else {
      addQuestion(quizId, {
        type: 'true-false',
        question: question.trim(),
        correctAnswer: selectedAnswer,
        quiz_id: parseInt(quizId),
        wrongAnswers: [],
        answerContains: '',
        answerEquals: ''
      });
    }  
  
    router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName, id: quizId } });
  };  

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.push({ pathname: '/(tabs)/quiz-screen', params: { name: quizName } })}>
          <Ionicons name="arrow-back" size={24} color="black" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>True or False</Text>
        <TouchableOpacity onPress={handleSave}>
          <Ionicons name="save" size={24} color="#009688" />
        </TouchableOpacity>
      </View>

      {/* Question Input */}
      <Text style={styles.label}>Question</Text>
      <TextInput
        style={styles.input}
        value={question}
        onChangeText={setQuestion}
        placeholder="Enter question"
      />

      {/* Answer Selection */}
      <View style={styles.answerContainer}>
        <TouchableOpacity
          style={[styles.answerOption, selectedAnswer === "True" && styles.selected]}
          onPress={() => setSelectedAnswer("True")}
        >
          <Text style={[styles.answerText, selectedAnswer === "True" && { color: "white" }]}>True</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.answerOption, selectedAnswer === "False" && styles.selected]}
          onPress={() => setSelectedAnswer("False")}
        >
          <Text style={[styles.answerText, selectedAnswer === "False" && { color: "white" }]}>False</Text>
        </TouchableOpacity>
      </View>

      {/* Modal for Validation */}
      <Modal visible={errorVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Validation Error</Text>
            <Text style={styles.modalText}>{errorMessage}</Text>
            <TouchableOpacity onPress={() => setErrorVisible(false)} style={styles.modalButton}>
              <Text style={styles.modalButtonText}>OK</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', padding: 20 },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 20 },
  headerTitle: { fontSize: 18, fontWeight: 'bold' },
  label: { fontSize: 16, marginBottom: 8 },
  input: { borderWidth: 1, borderColor: '#ccc', borderRadius: 6, padding: 10, marginBottom: 16 },
  answerContainer: { flexDirection: 'row', justifyContent: 'space-between', marginTop: 20 },
  answerOption: { paddingVertical: 12, paddingHorizontal: 20, borderWidth: 1, borderColor: '#ccc', borderRadius: 6 },
  answerText: { fontSize: 16 },
  selected: { 
    backgroundColor: '#009688', 
    borderColor: '#009688',
    color: 'white' // ‚úÖ Text will change to white on selection
  },  
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
  },
  modalContent: {
    backgroundColor: '#fff',
    width: '80%',
    padding: 20,
    borderRadius: 12,
    elevation: 10,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 8,
  },
  modalText: {
    fontSize: 14,
    color: '#333',
    textAlign: 'center',
    marginBottom: 12,
  },
  modalButton: {
    backgroundColor: '#009688',
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 6,
  },
  modalButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },  
});

--------
app/components/ExamContent.jsx

import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router'; // ‚úÖ Add this to ExamContent.jsx
import React, { useState } from 'react';
import { FlatList, Modal, StyleSheet, Switch, Text, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext'; // ‚úÖ Access stored quizzes

export default function ExamContent() {
  const { quizzes, selectedQuizzes, updateSelectedQuizzes } = useQuiz();
  const [modalVisible, setModalVisible] = useState(false);
  const [showAnswers, setShowAnswers] = useState(true); // ‚úÖ Toggle correct answers visibility 

  const router = useRouter();

  // ‚úÖ Handle quiz selection toggle
  const toggleQuizSelection = (quizName) => {
    updateSelectedQuizzes(selectedQuizzes.includes(quizName)
      ? selectedQuizzes.filter(q => q !== quizName)
      : [...selectedQuizzes, quizName]
    );
  };

  return (
    <View style={styles.container}>
      {/* Quiz Selection */}
      <TouchableOpacity onPress={() => setModalVisible(true)} style={styles.quizSelection}>
        <Text style={styles.label}>Quizzes</Text>
        <Text style={styles.selectedQuizText}>
          {selectedQuizzes.length ? selectedQuizzes.join(', ') : 'Tap to choose quizzes'}
        </Text>
      </TouchableOpacity>

      {/* Show Answers Toggle */}
      <View style={styles.toggleContainer}>
        <Text style={styles.label}>Show correct answers</Text>
        <Switch value={showAnswers} onValueChange={setShowAnswers} />
      </View>

      {/* Sort Option */}
      <TouchableOpacity style={styles.quizSelection}>
        <Text style={styles.label}>Sort questions by</Text>
        <Text style={styles.selectedQuizText}>Creation date</Text>
      </TouchableOpacity>

      {/* FAB Play Button */}
      <TouchableOpacity 
        style={styles.fab} 
        onPress={() => router.push({ pathname: '/(tabs)/quiz-taking', params: { quizzes: selectedQuizzes } })}
      >
        <Ionicons name="play-circle" size={80} color="#009688" />
      </TouchableOpacity>

      {/* Quiz Selection Modal */}
      <Modal visible={modalVisible} transparent animationType="fade">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <FlatList
              data={quizzes}
              keyExtractor={(item) => item}
              renderItem={({ item }) => (
                <TouchableOpacity onPress={() => toggleQuizSelection(item)} style={styles.modalItem}>
                  <Ionicons name={selectedQuizzes.includes(item) ? "checkbox" : "square-outline"} size={24} color="#009688" />
                  <Text style={styles.quizName}>{item}</Text>
                </TouchableOpacity>
              )}
            />
            <TouchableOpacity onPress={() => setModalVisible(false)} style={styles.modalButton}>
              <Text style={styles.modalButtonText}>Done</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', padding: 20 },
  quizSelection: { paddingVertical: 12, borderBottomWidth: 1, borderBottomColor: '#ccc' },
  label: { fontSize: 16, fontWeight: 'bold' },
  selectedQuizText: { fontSize: 16, color: '#666' },
  toggleContainer: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 12, borderBottomWidth: 1, borderBottomColor: '#ccc' },
  fab: { position: 'absolute', bottom: 15, right: 15 },
  modalOverlay: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.3)' },
  modalContent: { backgroundColor: '#fff', width: '80%', padding: 20, borderRadius: 12, elevation: 10 },
  modalItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: 12 },
  quizName: { fontSize: 16, marginLeft: 10 },
  modalButton: { backgroundColor: '#009688', paddingVertical: 10, alignItems: 'center', marginTop: 10, borderRadius: 6 },
  modalButtonText: { color: 'white', fontWeight: 'bold' },
});

-------
app/components/QuizzesContent.jsx

import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useEffect, useState } from 'react';
import { FlatList, Modal, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { useQuiz } from '../../context/QuizContext';
import { addQuiz, deleteQuiz, fetchQuizzes, addQuestion as addQuestionToDB, fetchQuestions } from "../../services/api"; // ‚úÖ Import API helper

export default function QuizzesContent() {
  const { quizzes, setQuizzes, quizQuestions } = useQuiz(); // ‚úÖ Includes quizQuestions  
  const [modalVisible, setModalVisible] = useState(false);
  const [quizName, setQuizName] = useState('');
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [selectedQuiz, setSelectedQuiz] = useState(null);
  const [actionModalVisible, setActionModalVisible] = useState(false);
  const [confirmDeleteModalVisible, setConfirmDeleteModalVisible] = useState(false);

  const router = useRouter();

  useEffect(() => {
    console.log("Quiz Questions from Context:", quizQuestions); // ‚úÖ Debugging log
  
    setQuizzes(prevQuizzes => [...prevQuizzes]); // ‚úÖ Force UI refresh
  
  }, [quizQuestions]); // ‚úÖ Refresh when questions change  

  const loadQuizzes = async () => {
    const data = await fetchQuizzes(); // ‚úÖ Fetch quizzes via PHP API
    console.log("Quizzes from MySQL:", data); // ‚úÖ Debugging: Check the console
    setQuizzes(data);
  };

  const handleAddQuiz = async () => {
    if (quizName.trim() !== '') {
        const success = await addQuiz(quizName.trim()); // ‚úÖ Send request to MySQL
        if (success) {
            loadQuizzes(); // ‚úÖ Refresh list after adding
            setQuizName(''); // ‚úÖ Clear input field
            setModalVisible(false); // ‚úÖ Close modal
        }
    }
  };  

  const handleCancel = () => {
    setQuizName('');
    setModalVisible(false);
  };

  const handleDeleteQuiz = async () => {
    if (selectedQuiz) {
      console.log("Attempting to delete quiz:", selectedQuiz.id);
  
      const success = await deleteQuiz(selectedQuiz.id);
      console.log("Quiz deletion success:", success);
  
      if (success) {
        setConfirmDeleteModalVisible(false); // ‚úÖ Close modal first
        setActionModalVisible(false); // ‚úÖ Close action modal too
        setSelectedQuiz(null); // ‚úÖ Clear selected quiz immediately
  
        await loadQuizzes(); // ‚úÖ Refresh list after state updates
      } else {
        console.error("Failed to delete quiz!");
      }
    }
  };

  const addQuestion = async (quizId, questionData) => {
    const success = await addQuestionToDB(quizId, questionData);
    if (!success) {
      console.error("‚ùå Failed to save question to database");
      return;
    }

    // ‚úÖ Fetch the updated list of questions from the DB
    const updatedQuestions = await fetchQuestions(quizId);

    setQuizQuestions(prev => ({
      ...prev,
      [quizId]: updatedQuestions
    }));
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={quizzes}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => router.push({ pathname: '/(tabs)/quiz-screen', params: { name: item.name, id: item.id.toString() }, })  } // ‚úÖ also pass id
            onLongPress={() => {
              setSelectedQuiz(item);
              setActionModalVisible(true);
            }}
          >
            <View style={styles.quizItem}>
              <Text style={styles.quizTitle}>{item.name}</Text>
              <Text style={styles.questionCount}>
                {quizQuestions[item.id] ? quizQuestions[item.id].length : 0} questions
              </Text>
            </View>
          </TouchableOpacity>
        )}
        contentContainerStyle={{ paddingBottom: 100 }}
      />

      {/* FAB */}
      <TouchableOpacity style={styles.fab} onPress={() => setModalVisible(true)}>
        <Ionicons name="add" size={28} color="white" />
      </TouchableOpacity>

      {/* Add Quiz Modal */}
      <Modal
        visible={modalVisible}
        transparent
        animationType="fade"
        onRequestClose={handleCancel}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Quiz name</Text>
            <TextInput
              placeholder="Enter quiz name"
              value={quizName}
              onChangeText={setQuizName}
              style={styles.input}
            />
            <View style={styles.modalButtons}>
              <TouchableOpacity onPress={handleCancel}>
                <Text style={styles.cancel}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={handleAddQuiz}>
                <Text style={styles.save}>Save</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Action Modal */}
      <Modal
        visible={actionModalVisible}
        transparent
        animationType="fade"
        onRequestClose={() => setActionModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.actionModalContent}>
            <Text style={[styles.modalTitle]}>{selectedQuiz?.name}</Text>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => {
                setActionModalVisible(false);
                router.push({ pathname: '/(tabs)/edit-quiz', params: { name: selectedQuiz.name } });
              }}
            >
              <Text style={styles.save}>Edit</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => {
                setConfirmDeleteModalVisible(true);
              }}
            >
              <Text style={{ color: 'red' }}>Delete</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => setActionModalVisible(false)}>
              <Text style={[styles.cancel, {marginRight: 0, paddingVertical: 10,}]}>Back</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Confirm Delete Modal */}
      <Modal
        visible={confirmDeleteModalVisible}
        transparent
        animationType="fade"
        onRequestClose={() => setConfirmDeleteModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Delete quiz?</Text>
            <Text>{selectedQuiz?.name}</Text>
            <View style={styles.modalButtons}>
              <TouchableOpacity onPress={() => setConfirmDeleteModalVisible(false)}>
                <Text style={styles.cancel}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={handleDeleteQuiz}>
                <Text style={[styles.save, { color: 'red' }]}>Delete</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  quizItem: {
    padding: 16,
    borderBottomColor: '#eee',
    borderBottomWidth: 1,
  },
  fab: {
    position: 'absolute',
    bottom: 25,
    right: 25,
    backgroundColor: '#009688',
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#fff',
    width: '80%',
    padding: 20,
    borderRadius: 12,
    elevation: 10,
  },
  actionModalContent: {
    backgroundColor: '#fff',
    width: '70%',
    padding: 20,
    borderRadius: 12,
    elevation: 10,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 12,
    textAlign: 'center',
    justifyContent: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 10,
    borderRadius: 6,
    marginBottom: 16,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 10,
  },
  cancel: {
    marginRight: 20,
    color: '#888',
    fontWeight: 'bold',
  },
  save: {
    color: '#009688',
    fontWeight: 'bold',
  },
  actionButton: {
    paddingVertical: 10,
  },
});

----------
app/components/SettingItem.jsx

import { View, Text, StyleSheet } from 'react-native';

export default function SettingItem({ title, children }) {
  return (
    <View style={styles.item}>
      <Text style={styles.title}>{title}</Text>
      <View>{children}</View>
    </View>
  );
}

const styles = StyleSheet.create({
  item: {
    padding: 16,
    borderBottomColor: '#ccc',
    borderBottomWidth: 1,
  },
  title: {
    fontWeight: 'bold',
    marginBottom: 8,
  },
});

--------
app/components/ToggleSetting.jsx

import React from 'react';
import { View, Text, Switch } from 'react-native';
import { colors } from '../../styles/colors';

export default function ToggleSetting({ label, value, onValueChange }) {
  return (
    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginVertical: 10 }}>
      <Text style={{ fontWeight: 'bold' }}>{label}</Text>
      <Switch value={value} onValueChange={onValueChange} thumbColor={colors.primary} />
    </View>
  );
}
-----
app/index.jsx

import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/(tabs)/top-tabs" />;
}

-------
context/QuizContext.jsx

// QuizContext.jsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { addQuestionToDB, fetchQuizzes, fetchQuestions } from '../services/api';

const QuizContext = createContext();

export const QuizProvider = ({ children }) => {
  const [quizzes, setQuizzes] = useState([]);
  const [quizQuestions, setQuizQuestions] = useState({});
  const [selectedQuizzes, setSelectedQuizzes] = useState([]);

  // ‚úÖ Load quizzes + questions on startup
  useEffect(() => {
    const loadQuizzesAndQuestions = async () => {
      const fetchedQuizzes = await fetchQuizzes();
      setQuizzes(fetchedQuizzes);

      const allQuestions = {};

      for (const quiz of fetchedQuizzes) {
        const questions = await fetchQuestions(quiz.id);
        console.log(`üì• Got questions for quiz ID ${quiz.id}:`, questions); // üîç NEW
        allQuestions[quiz.id] = questions;
      }

      setQuizQuestions(allQuestions);
      console.log("üß† All loaded questions:", allQuestions);
    };

    loadQuizzesAndQuestions();
  }, []);

  useEffect(() => {
    console.log("Updated quizQuestions:", quizQuestions);
  }, [quizQuestions]);

  const updateQuiz = (oldName, newName) => {
    setQuizzes(prevQuizzes =>
      prevQuizzes.map(quiz => quiz === oldName ? newName : quiz)
    );
    setQuizQuestions(prev => {
      const updatedQuestions = { ...prev };
      updatedQuestions[newName] = updatedQuestions[oldName] || [];
      delete updatedQuestions[oldName];
      return updatedQuestions;
    });
  };

  const addQuestion = async (quizId, questionData) => {
    const response = await addQuestionToDB(quizId, questionData);
    if (!response || !response.success) {
      console.error("‚ùå Failed to save question to database");
      return;
    }

    const newQuestion = {
      ...questionData,
      id: response.id,
      quiz_id: quizId,
      correctAnswer: questionData.correctAnswer ?? '',
      wrongAnswers: questionData.wrongAnswers ?? [],
      answerContains: questionData.answerContains ?? '',
      answerEquals: questionData.answerEquals ?? '',
    };

    setQuizQuestions(prev => ({
      ...prev,
      [quizId]: [...(prev[quizId] || []), newQuestion]
    }));
  };

  const updateQuestion = (quizId, questionId, newQuestion, correctAnswer, wrongAnswers, answerContains, answerEquals) => {
    setQuizQuestions(prev => ({
      ...prev,
      [quizId]: prev[quizId]?.map(q =>
        q.id == questionId
          ? {
              ...q,
              question: newQuestion,
              correctAnswer: typeof correctAnswer === 'string' ? correctAnswer.trim() : q.correctAnswer,
              wrongAnswers: Array.isArray(wrongAnswers) ? wrongAnswers.map(ans => ans.trim()) : q.wrongAnswers,
              answerContains: typeof answerContains === 'string' ? answerContains.trim() : q.answerContains,
              answerEquals: typeof answerEquals === 'string' ? answerEquals.trim() : q.answerEquals
            }
          : q
      ) || []
    }));
  };

  const removeQuestion = (quizId, questionId) => {
    setQuizQuestions(prev => ({
      ...prev,
      [quizId]: prev[quizId]?.filter(q => q.id !== questionId) || []
    }));
  };

  const updateSelectedQuizzes = (newSelections) => {
    setSelectedQuizzes(newSelections);
  };

  return (
    <QuizContext.Provider value={{
      quizzes,
      setQuizzes,
      quizQuestions,
      setQuizQuestions,
      addQuestion,
      updateQuiz,
      updateQuestion,
      removeQuestion,
      selectedQuizzes,
      updateSelectedQuizzes
    }}>
      {children}
    </QuizContext.Provider>
  );
};

export const useQuiz = () => useContext(QuizContext);

-----
services/api.js

import axios from 'axios';

const BASE_URL = "http://192.168.1.13/quizzer_backend";

export const addQuiz = async (quizName) => {
    try {
      const response = await axios.post(`${BASE_URL}/add-quiz.php`, 
        { name: quizName },
        { headers: { "Content-Type": "application/json" } } // ‚úÖ Explicitly set headers
      );
      return response.data.success;
    } catch (error) {
      console.error("Error adding quiz:", error);
      return false;
    }
};

export const fetchQuizzes = async () => {
    try {
      const response = await axios.get(`${BASE_URL}/get-quizzes.php`, {
        headers: { "Content-Type": "application/json" }, // ‚úÖ Explicitly set headers
      });
      return response.data;
    } catch (error) {
      console.error("Error fetching quizzes:", error);
      return [];
    }
};

export const updateQuiz = async (quizId, newName) => {
  try {
    const response = await axios.post(`${BASE_URL}/update-quiz.php`,
      { id: quizId, name: newName },
      { headers: { "Content-Type": "application/json" } }
    );

    console.log("Raw API Response:", response.data); // ‚úÖ Debugging log
    return response.data.success; // ‚úÖ Extracting success flag
  } catch (error) {
    console.error("Error updating quiz:", error);
    return false;
  }
}; 

export const deleteQuiz = async (quizId) => {
    try {
      const response = await axios.post(`${BASE_URL}/delete-quiz.php`,
        { id: quizId },
        { headers: { "Content-Type": "application/json" } } // ‚úÖ Explicitly set headers
      );
      return response.data.success;
    } catch (error) {
      console.error("Error deleting quiz:", error);
      return false;
    }
};  


export const addQuestionToDB = async (quizId, questionData) => {
  try {
    const response = await axios.post(`${BASE_URL}/add-question.php`, {
      quiz_id: quizId,
      ...questionData
    }, {
      headers: { "Content-Type": "application/json" }
    });

    return response.data; // returns { success: true, id: 123 }
  } catch (error) {
    console.error("Error adding question:", error);
    return { success: false };
  }
};

// // Fetch questions by quiz ID
// export const fetchQuestions = async (quizId) => {
//   try {
//     const response = await axios.get(`${BASE_URL}/get-questions.php?quiz_id=${quizId}`);
//     return response.data; // ‚úÖ Just return the questions
//   } catch (error) {
//     console.error('Error fetching questions:', error);
//     return [];
//   }
// };

// Fetch all questions for a specific quiz
export async function fetchQuestions(quizId) {
  try {
    const res = await fetch(`${BASE_URL}/get-questions.php?id=${quizId}`);
    return await res.json();
  } catch (err) {
    console.error(`‚ùå Failed to fetch questions for quiz ${quizId}:`, err);
    return [];
  }
};

// Delete a question
export const deleteQuestion = async (questionId) => {
  try {
    const response = await axios.post(`${BASE_URL}/delete-question.php`,
      { id: questionId },
      { headers: { "Content-Type": "application/json", }, }
    );
    return response.data.success;
  } catch (error) {
    console.error("Error deleting question:", error);
    return false;
  }
};

// Update a question
export async function updateQuestionInDB(id, questionData) {
  try {
    const res = await fetch(`${BASE_URL}/update-question.php`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id, ...questionData }),
    });

    return await res.json();
  } catch (err) {
    console.error('Error updating question in DB:', err);
    return { success: false };
  }
}

------
styles/colors.js

export const colors = {
    primary: '#009688',   // Teal-ish color (same vibe as in your screenshot)
    secondary: '#4CAF50', // Green
    accent: '#FFC107',    // Yellow
    text: '#212121',
    background: '#FFFFFF',
  };
  
-----------
quizzer_backend/add-question.php

<?php
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: POST, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type");

include 'db.php';

$data = json_decode(file_get_contents("php://input"));

if (
    isset($data->quiz_id) &&
    isset($data->type) &&
    isset($data->question)
) {
    $quiz_id = $data->quiz_id;
    $type = $data->type;
    $question = $data->question;

    // Optional fields (based on type)
    $correct_answer = $data->correctAnswer ?? null;
    $wrong_answers = isset($data->wrongAnswers) ? json_encode($data->wrongAnswers) : null;
    $answer_contains = $data->answerContains ?? null;
    $answer_equals = $data->answerEquals ?? null;

    $stmt = $conn->prepare("INSERT INTO questions (quiz_id, type, question, correct_answer, wrong_answers, answer_contains, answer_equals)
                            VALUES (?, ?, ?, ?, ?, ?, ?)");
    $stmt->bind_param("issssss", $quiz_id, $type, $question, $correct_answer, $wrong_answers, $answer_contains, $answer_equals);

    if ($stmt->execute()) {
        echo json_encode(["success" => true, "id" => $stmt->insert_id]);
    } else {
        echo json_encode(["success" => false, "error" => $stmt->error]);
    }

    $stmt->close();
} else {
    echo json_encode(["success" => false, "error" => "Missing required fields"]);
}

$conn->close();
?>

-----
quizzer_backend/add-quiz.php

<?php
include 'db.php';

// ‚úÖ Allow all origins (for development)
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: POST, GET, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type, Authorization");

// ‚úÖ Handle Preflight Requests (OPTIONS Method)
if ($_SERVER["REQUEST_METHOD"] === "OPTIONS") {
    http_response_code(200);
    exit();
}

header("Content-Type: application/json");

$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['name']) || empty($data['name'])) {
    echo json_encode(["success" => false, "message" => "Quiz name is required"]);
    exit();
}

$name = $data['name'];

$sql = "INSERT INTO quizzes (name) VALUES (?)";
$stmt = $conn->prepare($sql);
$stmt->bind_param("s", $name);
$stmt->execute();

echo json_encode(["success" => $stmt->affected_rows > 0]);
?>

-----
quizzer_backend/api.php

<?php
include 'db.php';

header('Content-Type: application/json');

$sql = "SELECT * FROM quizzes";
$result = $conn->query($sql);

$quizzes = [];

while ($row = $result->fetch_assoc()) {
    $quizzes[] = $row;
}

echo json_encode($quizzes);
?>

-----
quizzer_backend/db.php

<?php
$host = "localhost"; // Change if using an online server
$user = "root"; // Default MySQL user (change if needed)
$password = ""; // Default is empty for local servers
$database = "quizzer_db"; // Your MySQL database name

$conn = new mysqli($host, $user, $password, $database);

if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
}

header('Content-Type: application/json'); // Ensure JSON response
?>

-----
quizzer_backend/delete-question.php

<?php

header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Headers: *");
header("Content-Type: application/json");

// Connect to the database
include 'db.php';

$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['id'])) {
    echo json_encode(["success" => false, "message" => "Missing question ID"]);
    exit;
}

$questionId = intval($data['id']);

// Step 1: Delete the question
$deleteQuery = "DELETE FROM questions WHERE id = ?";
$stmt = $conn->prepare($deleteQuery);
$stmt->bind_param("i", $questionId);
$success = $stmt->execute();
$stmt->close();

if (!$success) {
    echo json_encode(["success" => false, "message" => "Failed to delete question"]);
    exit;
}

// Step 2: Reset IDs to 1, 2, 3... globally
$conn->query("SET @count = 0");
$conn->query("UPDATE questions SET id = @count := @count + 1 ORDER BY id");

// Step 3: Reset AUTO_INCREMENT to match the new max ID
$conn->query("ALTER TABLE questions AUTO_INCREMENT = 1");

echo json_encode(["success" => true, "message" => "Question deleted and IDs reset"]);

?>

-----
quizzer_backend/delete-quiz.php

<?php
include 'db.php';

header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: POST, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type, Authorization");

if ($_SERVER["REQUEST_METHOD"] === "OPTIONS") {
    http_response_code(200);
    exit();
}

header("Content-Type: application/json");

// ‚úÖ Get input data
$data = json_decode(file_get_contents("php://input"), true);
if (!isset($data['id'])) {
    echo json_encode(["success" => false, "message" => "Quiz ID is required"]);
    exit();
}

$quizId = intval($data['id']);

// ‚úÖ Delete the quiz
$sql = "DELETE FROM quizzes WHERE id = ?";
$stmt = $conn->prepare($sql);
$stmt->bind_param("i", $quizId);
$stmt->execute();

// ‚úÖ Shift IDs down to remove gaps
$conn->query("SET @num = 0");
$conn->query("UPDATE quizzes SET id = @num := @num + 1 ORDER BY id");

// ‚úÖ Reset AUTO_INCREMENT to maintain sequence
$conn->query("ALTER TABLE quizzes AUTO_INCREMENT = 1");

echo json_encode(["success" => true, "message" => "Quiz deleted and IDs reordered"]);
?>

-----
quizzer_backend/get-questions.php

<?php
include 'db.php';

header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Headers: *");
header("Access-Control-Allow-Methods: *");
header("Content-Type: application/json");

// ‚úÖ Handle preflight
if ($_SERVER["REQUEST_METHOD"] === "OPTIONS") {
    http_response_code(200);
    exit();
}

// ‚úÖ Get quiz ID from the query string
$quiz_id = isset($_GET['id']) ? intval($_GET['id']) : 0;

if ($quiz_id === 0) {
    echo json_encode(["success" => false, "message" => "Missing or invalid quiz ID"]);
    exit();
}

$sql = "SELECT * FROM questions WHERE quiz_id = ?";
$stmt = $conn->prepare($sql);
$stmt->bind_param("i", $quiz_id);
$stmt->execute();
$result = $stmt->get_result();

$questions = [];
while ($row = $result->fetch_assoc()) {
    $questions[] = [
        'id' => $row['id'],
        'quiz_id' => $row['quiz_id'],
        'type' => $row['type'],
        'question' => $row['question'],
        'correctAnswer' => $row['correct_answer'] ?? '',
        'wrongAnswers' => json_decode($row['wrong_answers'] ?? "[]"),
        'answerContains' => $row['answer_contains'] ?? '',
        'answerEquals' => $row['answer_equals'] ?? '',
    ];
}

echo json_encode($questions);

$stmt->close();
$conn->close();
?>

-----
quizzer_backend/get-quizzes.php

<?php
include 'db.php';

header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Headers: *");
header("Access-Control-Allow-Methods: *");
header("Content-Type: application/json");

// ‚úÖ Handle Preflight Requests (OPTIONS Method)
if ($_SERVER["REQUEST_METHOD"] === "OPTIONS") {
    http_response_code(200);
    exit();
}

// ‚úÖ Fetch quizzes from MySQL
$sql = "SELECT * FROM quizzes";
$result = $conn->query($sql);

$quizzes = [];
while ($row = $result->fetch_assoc()) {
    $quizzes[] = $row;
}

echo json_encode($quizzes);
?>

-----
quizzer_backend/update-question.php

<?php
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Headers: *");
header("Content-Type: application/json");

include 'db.php';

$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['id']) || !isset($data['type'])) {
    echo json_encode(["success" => false, "message" => "Missing required fields"]);
    exit;
}

$id = intval($data['id']);
$type = $data['type'];
$question = $data['question'] ?? '';
$correctAnswer = $data['correctAnswer'] ?? '';
$wrongAnswers = $data['wrongAnswers'] ?? [];
$answerContains = $data['answerContains'] ?? '';
$answerEquals = $data['answerEquals'] ?? '';

$wrongAnswersJson = json_encode($wrongAnswers);

// ‚úÖ Use correct DB column names
$sql = "UPDATE questions SET type = ?, question = ?, correct_answer = ?, wrong_answers = ?, answer_contains = ?, answer_equals = ? WHERE id = ?";
$stmt = $conn->prepare($sql);
$stmt->bind_param("ssssssi", $type, $question, $correctAnswer, $wrongAnswersJson, $answerContains, $answerEquals, $id);

if ($stmt->execute()) {
    echo json_encode(["success" => true]);
} else {
    echo json_encode(["success" => false, "message" => "Failed to update question", "error" => $stmt->error]);
}

$stmt->close();
$conn->close();
?>

-----
quizzer_backend/update-quiz.php

<?php
include 'db.php';

header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: POST, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type, Authorization");

if ($_SERVER["REQUEST_METHOD"] === "OPTIONS") {
    http_response_code(200);
    exit();
}

header("Content-Type: application/json");

$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['id']) || empty($data['name'])) {
    echo json_encode(["success" => false, "message" => "Quiz ID and new name are required"]);
    exit();
}

$id = intval($data['id']);
$newName = $data['name'];

error_log("Received ID: $id, New Name: $newName"); // ‚úÖ Debugging log

$sql = "UPDATE quizzes SET name = ? WHERE id = ?";
$stmt = $conn->prepare($sql);
$stmt->bind_param("si", $newName, $id);
$stmt->execute();

if ($stmt->affected_rows > 0) {
    echo json_encode(["success" => true, "message" => "Quiz renamed successfully"]);
} else {
    echo json_encode(["success" => false, "message" => "Quiz rename failed!", "error" => $conn->error]);
}
?>

-----------

This is the current file structure and its code.